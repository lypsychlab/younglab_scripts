function younglab_model_spm12_sirius_BIDS(varargin)
% Kevin Jiang
% Last updated: 5/28/19
%
% modified for BIDS, changed parameters
% e.g., model_one_subject('TPS_FMRIPREP','YOU_TPS_03','tom_localizer','tom','full_infile_TPS.csv')
%
% Old younglab_model_spm12_sirius documentation below (may be inaccurate)
% younglab_model_spm12
%
% Batch function for specifying and modeling a design matrix for one or
% more subjects in SPM8. At the minimum, it requires five arguments at the
% beginning: study, subject IDs, tasks, bold files, and bold directories.
%
% E.G. younglab_model_spm12_sirius_BIDS('BLI','YOU_BLI_01','fba_itemwise','fba',[1 2 3])
%       ==> would attempt to model  audio fb task by item (fba_itemwise), looking for
%           bold files with the filter 'fba', and selecting only bold runs 1,
%           2, and 3 with that filter, sending results to a new directory called
%           '<experiment root dir>/BLI/YOU_BLI_01/results/fba_itemwise_results'
%
% In addition, there are a number of optional parameters that affect the
% behavior of the script. By default, the following behavior will take
% place:
%         - Use an explicit mask generated by FSL with a threshold of 0.4
%         - Run art_batch, saving the regressors and including a screenshot
%             of the results, but not including the regressors in the
%             behavioural files.
%         - Use a filtering frequency of 128 seconds per cycle.
%         - Assume data are normalized.
%
% *********************** Options *****************************************
% All parameters may be modified by including extra arguments to the script
% in the form of strings. There are two types, "option" parameters and
% assignment parameters. Option parameters are single inputs that cause the
% script to change between discrete modes of operation. Assignment
% parameters change the value of a variable.
%
% Option parameters:
%     => 'RT'             Causes the script to integrate reaction-time
%                         regressors
%
%     => 'unnormed'       The script will expect unnormalized data.
%
%     => 'implicit_mask'  The script will use SPM's implicit masking, with a
%                         default masking threshold of 80% mean signal.
%
%     => 'no_art'         The script will not run artifact detection.
%
%     => 'legacy'         The script will function exactly as its
%                         predecessor, saxelab_model_bch_spm8.
%
%     => 'overwrite_mask' The script's default behavior is now to overwrite
%                         any mask that it finds. The 'overwrite_mask'
%                         option (confusingly) will disable this, causing
%                         it to *not* overwrite the mask.
%
%	  => 'dont_smash'	  Instead of overwriting old models, the script will
%						  simply generate more by appending a value onto
%						  the end of the directory name.
%
%	  => 'clobber'		  The script will now clobber old results
%						  whose names collide with current results
%						  directories without asking permission first.
%
% Assignment parameters:
%     These variables all change the behavior of the script by directly
%     changing the value of a variable.
%     => 'maskthresh = number'
%         Changes the masking threshold. Remember, whereas SPM uses percent
%         as the means of expressing the masking threshold, FSL uses
%         decimal values. Therefore, '80' in SPM as the masking threshold
%         is the equivalent of '0.8' in FSL.
%         Default (explicit mask): 0.5
%         Default (implicit mask): 80
%
%     => 'filter_frequency = number'
%         Changes the frequency cutoff for the high pass filter. The script
%         will warn you if you attempt to use a bad filtering frequency,
%         but changing it ahead of time will circumvent that. Expressed as
%         seconds-per-period. 'filter_frequency = 200' will filter anything
%         with a period greater than 200 seconds, or a frequency lower than
%         1/200 Hz.
%
%     => 'global_threshold = number'
%         threshold for outlier detection based on global signal
%         (default = 3)
%
%     => 'motion_threshold = number'
%         threshold for outlier detection based on motion
%         (default = 2)
%
%     => 'use_diff_motion = 1 or 0'
%         1: uses scan-to-scan motion to determine outliers
%         0: uses absolute motion
%         (default = 1)
%
%     => 'use_diff_global = 1 or 0'
%         1: uses scan-to-scan global signal change to determine outliers
%         0: uses absolute global signal values
%         (default = 0)
%
%     => 'root_dir = STRING'
%         Changes the root directory. Should probably not be used. If you
%         must change the root directory, you must pass it in with escaped
%         quotes. Like: 'root_dir = ''some string'''
%
%	  => 'old_names = 1'
%		  This causes the script to assume the same naming conventions as
%		  the old modeling script (i.e. naming it purely based on the behavioural
%		  file and whether or not the data was normalized.)
%
% Some usage examples:
%
% younglab_model_spm12_sirius_BIDS('MNM',{'YOU_MNM_01','YOU_MNM_02'},'mnm','mnm',[6 8 10 12],'unnormed','implicit_mask','maskthresh = 60');
%
%     This would perform the analysis, but on unnormed data, and using SPM's
%     own masking system. Since the masking threshold defaults to 80% if you
%     specify an implicit mask, the user has changed it to 60%.
%
% Additional Notes:
%
%     - The script saves a screenshot of the art_batch results as
%       artifact_analysis_SUBJECT_TASK.png
%	  - The script will save screenshots of its frequency analysis on the
%	    conditions being run, so that you can review them later.
%     - The script will never overwrite old data, instead it will simply
%       create a new results directory with the same name but a "2" or "3"
%       (etc) appended to it.
%     - The script saves information about who performed the analysis,
%       when it was performed, and the parameters used in a text file stored
%       in the results directory, named 'whatever the results directory is +
%       metadata.txt'
%     - The script remodeler() will integrate artifact data, by changing
%       the behavioural files and modeling again using this script.
%
%  ======================= Multi-subject/task batching =======================
% The logic governing the interpretation of 'subjIDs' is the same as in
% the dicom and preprocessing scripts - If provided with a string the
% script will search through '<software root dir>/study' for a match, and if none is
% found it will attempt to use this string as a filter on this directory
% instead.  The script interprets a cell array as a list of subjects.
%
% 'tasks', 'boldfiles' and 'boldirs' may also be elaborated into cells that
% saxelab_model_bch will then attempt to step through, but the effect is the
% same as repeating the function call with each argument.  For all three args,
% provide information about the task within subject information.  That is,
% provide a cell that contains a series of task cells within subject cells.
%       e.g. {{'task1','task2'},{'task1','task3'}}
%
% E.G. (simple)
% younglab_model_spm12_sirius_BIDS('BLI','YOU_BLI_01','fbv_itemwise','fbv'[3 10 13])
% E.G. (crazy)
% younglab_model_spm12_sirius_BIDS('BLI',{'YOU_BLI_01','YOU_BLI_02','YOU_BLI_03'},...
% {{'fba_itemwise','fbv_itemwise','BLI_itemwise'},{'fba','BLI'}},{{'fba','fbv','BLI'},...
% {'fba','BLI'}}{{[5 9 14],[3 10 13],[7 8 11 12]},{[5 10 13],[7 8 11 12]},{[3 9 12],[4 8 13],...
% [6 7 10 11]}})
% This one actually would work, provided behavioural data, but in practice
% will typically only be run by your pstream script in which all these
% values are hard coded.

% Usage note:
% 1) This script depends on the presense of the 2 variables 'ips' and
% 'spm_inputs' in an individual mat file for every run that is to be
% included in the model.  These matfiles should be located in the 'behavioural'
% directory and named with the following format: subjID.task.acq.mat
%       ips is a integer used to set the number of functional runs
%       spm_inputs is a scructure with fields name, ons, and dur
%
% 2) The script also searches for the optional variables "con_info" and
% "user_regressors".
%   Syntax:
%       con_info(index).name = 'some name';
%       con_info(index).vals = [array of values of length numruns];
%
%       user_regressors(index).name = 'regressor name';
%       user_regressors(index).ons = [array of numbers of length ips];
%
%
% 3) IMPORTANT: these files are loaded by filtering the directory, NOT
% directly.  Therefore the script knows nothing of acq numbers, and to
% exclude a run from the model you must MOVE/REMOVE the appropriate matfile
% from the behavioural directory.  It is not enough to simply omit the bold
% directory in the function call (unless it was the last run), since the
% script sequentially pairs the list of matfiles to corresponding boldirs.
% 4) In cases where tasks, boldfiles, or boldirs is the same across subjects
% you may omit repetitions - the script copies the first cell out to the
% appropriate number of subjects
%
% Created by npd - 11/15/2010

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% begin by processing all the variables
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% turn off window elements
set(0,'DefaultFigureVisible','off');

global EXPERIMENT_ROOT_DIR
global skip_art;
global mask_over;
global defaults;

addpath(genpath('/data/younglw/lab/scripts'));
addpath(genpath('/usr/public/spm/spm12'));
EXPERIMENT_ROOT_DIR = '/data/younglw/lab';
TR               = 2;
src_data_flag    = 'normed';
RT_flag          = 0;
implicit_flag    = 0;
filter_frequency = 128;
maskthresh       = 0.4;
global_mean      = 1;
motion_file_type = 0;
global_threshold = 3;
motion_threshold = 2;
use_diff_motion  = 1;
use_diff_global  = 0;
addMotion        = 0;
addRegressors    = 0;
saveim           = 1;
addOnlyMotion    = 0;
skip_art         = 0;
mask_is_def      = 0;
freq_is_def      = 0;
is_legacy        = 0;
mask_over        = 1;
dont_smash		 = 0;
old_names		 = 0;
clobber_bit		 = 0;

defaults.maskthresh = maskthresh;
defaults.filter_frequency = filter_frequency;
defaults.implicit_flag = implicit_flag;

if nargin == 0
    help younglab_model_spm8;
    return;
elseif nargin<5
    disp('error: younglab_model_spm8 requires a minimum of 4 arguments');
    disp('`study`, `subjIDs`, `tasks`,`boldfiles`, & `boldirs` required');
    return
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% process study + subjects
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Elaborate subjects into a cell if they're not in one already
if ~iscell(varargin{2})
    varargin{2} = {varargin{2}};
end

study           = varargin{1};
subject         = varargin{2};

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% process tasks and boldfiles
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

if ~iscell(varargin{3})
    disp('Warning: `tasks` argument not provided in cell format!');
    tasks = {{varargin{3}}};
elseif iscell(varargin{3}{1})
    tasks = varargin{3};
else
    tasks = {varargin{3}};
end
for lazy = (length(tasks)+1):(length(subject)-length(tasks)+1)
    tasks{lazy} = tasks{1};
end

if ~iscell(varargin{4})
    disp('Warning: `boldfiles` argument not provided in cell format!');
    boldfiles = {{varargin{4}}};
elseif iscell(varargin{4}{1})
    boldfiles = varargin{4};
else
    boldfiles = {varargin{4}};
end
for lazy = (length(boldfiles)+1):(length(subject)-length(boldfiles)+1)
    boldfiles{lazy} = boldfiles{1};
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% process bold directories
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% check for infile
% if exists, replace boldir appropriately
% Kevin Jiang, 5/28/19: boldirs specified by infile

% mytemp = split(varargin{5}, '=');  % mytemp is x1 string array split on '='
% if length(mytemp) > 1 && strcmp(mytemp{1}, 'infile') == 1 % handling infile varargin with minor error checking
%     infile = mytemp{2}
%     boldirs = {{extract_behav_runs_from_infile(EXPERIMENT_ROOT_DIR,study,subject{1},tasks{1}{1},infile)}}  % replace boldirs w/ infile data

if strcmp(class(varargin{5}),'char') || strcmp(class(varargin{5}), 'string')  % handling infile varargin if string or char
    infile = varargin{5};
    behavioural_file_runs = extract_behav_runs_from_infile(EXPERIMENT_ROOT_DIR,study,subject{1},tasks{1}{1},infile)
    
    % assumes that BIDS folders are numbered contiguously (without gaps) starting from 1 and these correspond to behavioural .mat files in alphabetically sorted order
    boldirs = {{[1:length(behavioural_file_runs)]}}  
    % boldirs = {{extract_behav_runs_from_infile(EXPERIMENT_ROOT_DIR,study,subject{1},tasks{1}{1},infile)}}  % replace boldirs w/ infile data
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
else
    if ~iscell(varargin{5})
    	disp('Warning: `boldirs` argument not provided in cell format!');
    end
    if strcmp(class(varargin{5}),'double')
        boldirs = {{varargin{5}}};
    elseif iscell(varargin{5}{1})
        boldirs = varargin{5};
    elseif iscell(varargin{5}) & iscell(varargin{2}) % assume that each array w/in a cell refers to a separate subj, not a separate task
        for i=1:length(varargin{5});boldirs{i} = varargin{5}(i);end;
    elseif iscell(varargin{5}) & isstr(varargin{2}) % assume that there is one subject w/ several tasks and partition vararg 5 appropriately
        boldirs = {varargin{5}};
    end
    for lazy = (length(boldirs)+1):(length(subject)-length(boldirs)+1)
        boldirs{lazy} = boldirs{1};
    end
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% now iterate through the
% remaining varargin values, and
% assign variables as necessary.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

for i = 6:length(varargin)
    switch varargin{i}
        case 'RT'
            RT_flag = 1;
        case 'unnormed'
            src_data_flag = 'unnormed';
        case 'normed'
            src_data_flag = 'normed';
        case 'implicit_mask'
            implicit_flag = 1;
            if ~mask_is_def
                maskthresh    = 80;
            end
        case 'no_art'
            skip_art = 1;
        case 'legacy'
            is_legacy = 1;
        case 'overwrite_mask'
            mask_over = 0;
		case 'dont_smash'
			dont_smash = 1;
		case 'clobber'
			clobber_bit = 1;
        otherwise
            try
                eval(varargin{i});
                if strfind(varargin{i},'maskthresh')
                    mask_is_def = 1;
                end
                if strfind(varargin{i},'filter_frequency')
                    freq_is_def = 1;
                end
            catch
                disp(fprintf('''%s'' returned an error. Ignoring.',varargin{i}));
            end
    end
end

if is_legacy
    skip_art = 1;
    implicit_flag    = 1;
    filter_frequency = 128;
    maskthresh       = 80;
end

global inStruct;

inStruct.global_mean = global_mean;
inStruct.motion_file_type = motion_file_type;
inStruct.global_threshold = global_threshold;
inStruct.motion_threshold = motion_threshold;
inStruct.use_diff_motion = use_diff_motion;
inStruct.use_diff_global = use_diff_global;
inStruct.addMotion = addMotion;
inStruct.saveim = saveim;
inStruct.addRegressors = addRegressors;
inStruct.addOnlyMotion = addOnlyMotion;
inStruct.old_names = old_names;
inStruct.src_data_flag = src_data_flag;
inStruct.dont_smash = dont_smash;
inStruct.clobber_bit = clobber_bit;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% begin modeling
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


tic;
[ErrorLog,SPM]=model(study,subject,tasks,boldfiles,boldirs,src_data_flag,TR,RT_flag,implicit_flag,filter_frequency,maskthresh);

model_time_el = toc;

% show errors if log isn't empty:
err_bool = (length(ErrorLog)>0);
err_strs = {'without','with'};
if err_bool
    ErrorLog{:}
end
fprintf('Design & estimation completed %s errors in %d minutes and %.1f seconds\n',err_strs{1+err_bool},floor(model_time_el/60),mod(model_time_el,60));
set(0,'DefaultFigureVisible','on');
cd(fullfile(EXPERIMENT_ROOT_DIR,study));
end % Main Body

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%-------------------------------------------------------------------------%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function [ErrorLog,SPM]=model(study,subject,tasks,boldfiles,boldirs,src_data_flag,TR,RT_flag,implicit_flag,filter_frequency,maskthresh)
global EXPERIMENT_ROOT_DIR;
global skip_art;
global defaults;
global inStruct;
ErrorLog={};SPM=[];


for subj = 1:length(subject)

        fprintf('%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n');
        fprintf('Beginning estimation & contrasts on subject %s \n',subject{subj});
        fprintf('%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n');

        subj_bids    = {};
        for subj = 1:length(subject)
          subj_num = subject{subj}(end-1:end);
          subj_bids{end+1}= strcat('sub-',subj_num); %define subject labels for BIDS format
        end

        for task = 1:length(tasks{subj})
            fprintf('Subject: %s    Task: %s\n',subject{subj},tasks{subj}{task});
            clear spm_inputs con_info ips scans; SPM=[];
            if strmatch(src_data_flag,'normed')
                filter='MNI*preproc*.nii.gz';
            elseif strmatch(src_data_flag,'unnormed')
                filter = 'T1w_preproc.nii.gz'
            else
                disp('src_data_flag: illegal value.  "normed" & "unnormed" allowed');
            end
            disp(filter);

            cd(fullfile(EXPERIMENT_ROOT_DIR,study,'behavioural'));
            behavdata_thistask = dir(sprintf('%s.%s.*.mat',subject{subj},tasks{subj}{task}));
            num_behav_files = length(behavdata_thistask); % grabs mat files for this task for all acq
            clear vec;
            if num_behav_files
                % now do some explicit sorting (bug realized in prose for alpha-sort)
                % kevin note (5/29/19): assumes that behavioural files numbered (e.g., YOU_TPS_02.TPS.3.mat) and in same order as bold runs
                for i=1:num_behav_files % zip through the files and excerpt the acq #
                    therest = behavdata_thistask(i).name; % initialize for strtok
                    while ~strcmp(therest,'.mat')
                        [str,therest] = strtok(therest,'.'); % parse for acq
                    end
                    vec(i)=str2num(str);
                end
                sorted_vec = sort(vec);  % run numerical sort on behavioural file numers
                clear parafiles; % else you will run into problems when subject n has fewer behavioural files than subject n-1
                for i=1:num_behav_files
                    parafiles{i}=behavdata_thistask(vec==sorted_vec(i)).name; % finally reorganize w/ find
                end
            else
                error(sprintf('Couldn''t find behavioural data matching %s.%s.*.mat',subject{subj},tasks{subj}{task}));
            end
            num_runs = length(boldirs{subj}{task}); %prevents runover from excess behav data
            if num_runs ~= num_behav_files
                fprintf('Warning: number of behavioural data files does not match the\n');
                fprintf('number of runs for subject %s\n',subject{subj});
            end

            scans = [];

            cd(fullfile(EXPERIMENT_ROOT_DIR,study,subject{subj},'results'));
            % BUILD RESULTS STRING
            % (constructs an appropriate name for the results)
            results_string = [tasks{subj}{task} '_results_' src_data_flag];
			if ~inStruct.old_names
				if RT_flag
					results_string = [results_string '_RT'];
				end
				if implicit_flag
					results_string = [results_string '_IMP_maskt'];
					if maskthresh ~= 80
						results_string = [results_string '_' num2str(maskthresh)];
					end
				end
				if filter_frequency ~= defaults.filter_frequency;
					results_string = [results_string '_hpf_' num2str(filter_frequency)];
				end
				if (~implicit_flag) & (maskthresh ~= defaults.maskthresh)
					results_string = [results_string '_thr_' num2str(maskthresh)];
				end
				a = exist(results_string,'dir');
				append_digit = 2;
				results_string_pre = results_string;
				if inStruct.dont_smash
					while a
						results_string = [results_string_pre '_' num2str(append_digit)];
						a = exist(results_string,'dir');
						append_digit = append_digit+1;
					end
				else
					if exist(results_string,'dir')
						if ~inStruct.clobber_bit
							removeDir = questdlg('Old results directory found! Delete?','Dir with same name found','Yes','No','No');
							if strcmpi(removeDir,'Yes')
                                fclose('all');
								unix(sprintf('rm -rf %s',results_string));
							end
                        else
                            fclose('all');
							unix(sprintf('rm -rf %s',results_string));
						end
					end
				end
            else
                if exist(results_string,'dir')
                    if ~inStruct.clobber_bit
						removeDir = questdlg('Old results directory found! Delete?','Dir with same name found','Yes','No','No');
						if strcmpi(removeDir,'Yes')
							unix(sprintf('rm -rf %s',results_dir));
						end
					else
						unix(sprintf('rm -rf %s',results_dir));
					end
                end
			end
            results_string;
            mkdir(results_string);
            cd(results_string);
            rS1 = pwd;
            set(0,'DefaultFigureVisible','Off');
            % Now, write metadata about the results to the directory
            if RT_flag == 1
                rt_text = 'yes';
            else
                rt_text = 'no';
            end
            if implicit_flag
                mask_type_text = 'Implicit masking';
            else
                mask_type_text = 'Explicit masking';
			end
            fid = fopen([results_string '_metadata.txt'],'w');
            fprintf(fid,'Date of Analysis:      %s\n',datestr(now));
            fprintf(fid,'Experimenter:          %s\n',getenv('USER'));
            fprintf(fid,'Study:                 %s\n',study);
            fprintf(fid,'Subject:               %s\n',subject{subj});
            fprintf(fid,'Tasks:                 %s \n',tasks{subj}{1:length(tasks{subj})});
            fprintf(fid,'Bold directories:      %d \n',boldirs{subj}{1:length(boldirs{subj})});
            fprintf(fid,'Preprocessing:         %s\n',src_data_flag);
            fprintf(fid,'TR:                    %d\n',TR);
            fprintf(fid,'RTs included:          %s\n',rt_text);
            fprintf(fid,'Masking type:          %s\n',mask_type_text);
            fprintf(fid,'Filter frequency:      %.4f\n',filter_frequency);
            fprintf(fid,'Masking threshold:     %.4f\n',maskthresh);
            if ~skip_art
                fprintf(fid,'Global Mean:           %.4f\n',inStruct.global_mean);
                fprintf(fid,'Motion File Type:      %.4f\n',inStruct.motion_file_type);
                fprintf(fid,'Global Threshold:      %.4f\n',inStruct.global_threshold);
                fprintf(fid,'Motion Threshold:      %.4f\n',inStruct.motion_threshold);
                fprintf(fid,'use_diff_motion:       %.4f\n',inStruct.use_diff_motion);
                fprintf(fid,'use_diff_global:       %.4f\n',inStruct.use_diff_global);
            else
                fprintf(fid,'Global Mean:           %s\n','While this analysis may have the artifact regressors integrated, art_batch was not run.');
                fprintf(fid,'Motion File Type:      %s\n','While this analysis may have the artifact regressors integrated, art_batch was not run.');
                fprintf(fid,'Global Threshold:      %s\n','While this analysis may have the artifact regressors integrated, art_batch was not run.');
                fprintf(fid,'Motion Threshold:      %s\n','While this analysis may have the artifact regressors integrated, art_batch was not run.');
                fprintf(fid,'use_diff_motion:       %s\n','While this analysis may have the artifact regressors integrated, art_batch was not run.');
                fprintf(fid,'use_diff_global:       %s\n','While this analysis may have the artifact regressors integrated, art_batch was not run.');
            end

            for run = 1:num_runs
                cd(fullfile(EXPERIMENT_ROOT_DIR,study,'behavioural'));
                clear RT
                %CHANGE (JOSH): prevented from loading user_regressors so that we could run w.o regressing spm derived motion covariates (which don't apply to fmriprep).
                % load(parafiles{run},'spm_inputs','con_info','ips','RT','design');
                %(Kevin, 5/29/19): with new BIDS/fmriprep pipeline, we should be adding user_regressors, since they acompcor is added here?
                load(parafiles{run},'spm_inputs','con_info','ips','user_regressors','RT','design');

                if ~exist('spm_inputs') | ~exist('ips')
                    fprintf('Failed to load behavioural data for subject %s task `%s`\n',subject{subj}, tasks{subj}{task});
                    fprintf('\t-variables "spm_inputs" and "ips" required (and "con_info" is handy)\n');
                    fprintf('\t-crashing on pass %d...\n\n',task);
                elseif ~exist('con_info')
                    fprintf('No ''con_info'' variable detected for subject %s task `%s`\n',subject{subj}, tasks{subj}{task});
                end

                cd(fullfile(EXPERIMENT_ROOT_DIR,study,subject{subj},'results',results_string));

                %---------------------------------------------------
                % User-defined parameters for this analysis
                %---------------------------------------------------


                SPM.nscan(run)     = ips;                   % number of scans for each of nsess sessions
                SPM.xY.RT          = TR;                    % experiment TR in seconds
                SPM.xGX.iGXcalc    = {'Scaling'};           % global normalization: OPTIONS:'Scaling'|'None'
                SPM.xX.K.HParam    = filter_frequency;      % high-pass filter cutoff (secs) [Inf = no filtering]
                SPM.xVi.form       = 'none';                % intrinsic autocorrelations: OPTIONS: 'none'|'AR(1) + w'

                % basis functions and timing parameters
                %---------------------------------------------------------------------------
                SPM.xBF.name       = 'hrf';
                % OPTIONS:'hrf'
                %         'hrf (with time derivative)'
                %         'hrf (with time and dispersion derivatives)'
                %         'Fourier set'
                %         'Fourier set (Hanning)'
                %         'Gamma functions'
                %         'Finite Impulse Response'
                SPM.xBF.T          = 16; %25;            % number of time bins per scan
                SPM.xBF.T0         = 1;  %13;            % reference time bin
                SPM.xBF.UNITS      = 'scans';        % OPTIONS: 'scans'|'secs' for onsets
                SPM.xBF.Volterra   = 1;             % OPTIONS: 1|2 = order of convolution; 1 = no Volterra


                % design (conditions and user specified covariates)
                %---------------------------------------------------------------------------

                %conditions
                %----------

				% check to make sure the onsets are correct
				if max(horzcat(spm_inputs(:).ons)) > ips % saxelab uses vertcat but horzcat should do the same thing
					warning('\n----------------------------------------\nYour maximum onset: %.0f is greater than your ips (%.0f)!\n',max(vertcat(spm_inputs(:).ons)),ips);
					onset_resp = input(sprintf('Do you want to e(x)it, (c)onvert the onsets to TRs, or (p)roceed anyway? (type x or c or p)\t'),'s');
					if strcmpi(onset_resp,'x')
						return;
					elseif strcmpi(onset_resp,'c')
						disp('Fixing onsets for behavioural file %s. Note that this fix is not permanent.',parafiles{run});
						for onsTask = 1:length(spm_inputs)
							spm_inputs(onsTask).ons = spm_inputs(onsTask).ons/2+1;
						end
					end
				end
                for cond = 1:length(spm_inputs)
                    % SUBTRACTING 1 BECAUSE SPM FIRST IMAGE = 0
                    % this is later fixed in jc_get_design before
                    % extracting roi data in roi_batch.
                    % nevertheless, you must code onsets assuming the first
                    % image is 1.
                    SPM.Sess(run).U(cond).ons    = spm_inputs(cond).ons - 1;  % onsets in scans.
                    SPM.Sess(run).U(cond).name   = {spm_inputs(cond).name};   % string from spm_inputs.name
                    SPM.Sess(run).U(cond).dur    = spm_inputs(cond).dur;      % duration in scans from spm_inputs.dur
                    SPM.Sess(run).U(cond).P.name = 'none';                    % 'none' | 'time' | 'other'
                end

                % sample for using parametric modulation
                %SPM.Sess(subj).U(cond).P.name = 'time';      % 'none' | 'time' | 'other'
                %SPM.Sess(subj).U(cond).P.h = 1;              % order of polynomial expansion
                %or
                %SPM.Sess(subj).U(cond).P.name = 'other';     % 'none' | 'time' | 'other'
                %SPM.Sess(subj).U(cond).P.P = param{j}{1}     % vector as long as current U's ons vector
                %SPM.Sess(subj).U(cond).P.h = 1;              % order of polynomial expansion


                % ---------------------------------------------------
                % to automatically include RT informartion as a regressor
                if RT_flag==1
                    fprintf('\nAdding RT information as a regressor for: %s. . . \n',subject{subj});
%                     try
                        if ~exist('design') && exist('item_vector')
                            d = item_vector; % if design is missing, this will do.
                        else
                            d = design;
                        end

                        % if fixation 0's in RT and design
                        if ~isempty(find(d==0)) && length(RT) == length(d)
                            RT = RT(find(d));
                        end

                        % generate a vector of all onsets
                        tp=[];tdur=[];

                        for i=1:length(spm_inputs)
                            tp   = [tp spm_inputs(i).ons'];
                            tdur = [tdur spm_inputs(i).dur'];
                        end
                        [tp,ord] = sort(tp);% vector of timepoints
                        tdur     = tdur(ord);% sort durations too.

                        % mean-center non-missed RTs
                        RT(find(RT)) = RT(find(RT))-mean(RT(find(RT)));

                        % now make RT regressors
                        RT_run = zeros(1,ips);

                        % RT_run is now a vector of zeros, length=ips, with
                        % each trial onset value set to the mean-centered
                        % RT value. missed trials = 0
                        for i=1:length(tp)
                            RT_run(tp(i):tp(i)+tdur(i)-1) = ones(tdur(i),1)*RT(i);
                        end

                        % convolve RT with an HRF response
                        RT_run = hrf_convolve(RT_run);

                        % add them to user_regressors, to be used in the next step.
                        if exist('user_regressors')
                            user_regressors(end+1).name = 'RT';
                            user_regressors(end+1).ons  = RT_run;
                        else
                            user_regressors(1).name = 'RT';
                            user_regressors(1).ons  = RT_run;
                        end
                end

                % user-specified covariates
                % -------------------------
                SPM.Sess(run).C.name = {}; num_regressors = 0;
                if exist('user_regressors')
                    for reg=1:length(user_regressors)
                        SPM.Sess(run).C.C(:,reg) = user_regressors(reg).ons;  % [n x c double] covariates (n=regressor, c=vector of images)
                        SPM.Sess(run).C.name = [{SPM.Sess(run).C.name{:}} {user_regressors(reg).name}];   % [1 x c cell] - append to condition names
                    end
                    num_regressors = length(user_regressors);
                else
                    SPM.Sess(run).C.C = [];
                    SPM.Sess(run).C.name = {};
                end

                % make sure defaults are present in workspace
                % mK & KJ: spm_defaults 
                % spm_defaults = spm_defaults_lily;
                spm_defaults;

                % Get filenames for functional scans - changed by "normed"
                %===========================================================================

                % Pull out some information to save for error checking...
                formatted_run_num = sprintf('%02d', boldirs{subj}{task}(run));
                % split_files_dirog = ['/data/younglw/lab/' study '/derivatives/fmriprep/' subj_bids{subj} '/func/' boldfiles{subj}{task} '_run_0' num2str(boldirs{subj}{task}(run))];  % old logic only works when run num < 10
                split_files_dir = ['/data/younglw/lab/' study '/derivatives/fmriprep/' subj_bids{subj} '/func/' boldfiles{subj}{task} '_run_' formatted_run_num];
                files{run} = alek_get(split_files_dir,'smooth*bold_0*nii');
                % if isequal(subject, {'YOU_TRAG_05'}) % literally only for subject-05 case
                %     files{run} = alek_get(split_files_dir,'smooth*Asym_preproc_0*nii');  % don't take Jordan's AROMA smoothed things
                % end
                %Probably won't need this if files are being split at an earlier stage
                %if 7 == exist(split_files_dir,'dir')
                %  fprintf('Unzipped directory already exists')
                %  files{run} = alek_get(split_files_dir,'smooth*nii');
                %else
                %  run_zip = alek_get(sprintf('%s/%s/derivatives/fmriprep/%s/func',EXPERIMENT_ROOT_DIR,study,subj_bids{subj}),strcat(subj_bids{subj},'*',boldfiles{subj}{task},sprintf('*%.2d*',boldirs{subj}{task}(run)),filter));
                %  unzipped = gunzip(run_zip);
                %  mkdir(split_files_dir);
                %  spm_file_split(unzipped{1},split_files_dir);
                %  files{run}= alek_get(split_files_dir,'*nii');
                %end

                expected_num_files(run) = ips;

                fprintf('loading image files for run %d \n',boldirs{subj}{task}(run));
                scans = [scans; files{run}];
                clear spm_inputs ips user_regressors

            end % run/acq loop

            % To skip spm_bch_tsampl5
            % =========================================================
            SPM.xX.BCH = 1;
            SPM.xX.dropscan = [];

            % For spm_bch_tsampl5:
            % If you ever have a really, really good reason to omit more than the first
            % scan - and only then - you can use this flag to call up spm_bch_tsampl5,
            % a subroutine which will knock out various rows of your design matrix.
            % Unless it has been radically changed from spm_bch_tsampl3, its spm99
            % predecessor, doing so will almost certainly foul up things like IRF
            % estimation and so forth - so proceed with caution...
            %===========================================================================
            % Usage = Set SPM.dropscan equal to cell array with each cell containing
            % an array of the desired scan indices to drop within each session.  Each
            % cell corresponds to the equivalent session.  The example here is a four-
            % session experiment, dropping the first three scans in each session. Note
            % that the double curly braces are important.  Also make sure to comment out
            % the above two-line section, "To skip spm_bch_tsampl5."

            % SPM.xX.BCH = 1;
            % SPM.dropscan = {{[1:3] [1:3] [1:3] [1:3]}};

            % specify data: matrix of filenames and TR
            %===========================================================================
            SPM.xY.P = scans;

            % Run some basic tests before you let spm_fmri_spm_ui do its
            % thing (to test if the loaded information matches bold data)
            for i=1:num_runs
                if isempty(files{i})
                    fprintf('\nNo files matching "%s" were found in the directory\n',strcat(subj_bids{1},sprintf('*%.2d*',1),filter));
                    fprintf('"%s/%s/derivatives/fmriprep/%s/func", (run %d)\n\n',EXPERIMENT_ROOT_DIR,study,subj_bids{subj},boldirs{subj}{task}(i),i);
                elseif length(files{i}) < expected_num_files(i)
                    fprintf('\nThe ips doesn''t match the number of image files in\n');
                    fprintf('"%s/%s/derivatives/fmriprep/%s/func", (run %d)\n\n',EXPERIMENT_ROOT_DIR,study,subj_bids{subj},boldirs{subj}{task}(i),i);
                end

            end

            save SPM SPM
            pwd_art = pwd;

            % SAVE user information in the results directory.

            % Configure design matrix
            %===========================================================================
                SPM = spm_fmri_spm_ui_pleiades(SPM);

                if implicit_flag == 1
                    SPM.xM.T           = ones(length(scans),1);
                    SPM.xM.TH          = ones(length(scans),1) * maskthresh;
                    SPM.xM.I           = 0;
                    SPM.xM.VM          = [];
                    SPM.xM.xs.Masking  = 'analysis threshold';
                else
                    skullStripMaker(study,subj_bids{subj},maskthresh)
                    SPM.xM.T           = SPM.xM.T;
                    SPM.xM.TH          = SPM.xM.TH * -Inf;
                    SPM.xM.I           = 0;
                    SPM.xM.VM          = spm_vol([fullfile(EXPERIMENT_ROOT_DIR,study,'derivatives/fmriprep/',subj_bids{subj},'anat') '/skull_strip_mask.nii']);
                    SPM.xM.xs.Masking  = sprintf('Skull-stripped mask, made with FSL, threshold: %0.01f',maskthresh);
                end

            close all;

            if ~skip_art
                art_maker(inStruct, pwd_art, subject{subj}, tasks{subj}{task});
            end

            % Estimate parameters
            %===========================================================================

            SPM = spm_spm_pleiades(SPM);

            % T-contrasts - if con_info existed in any sourced data file,
            % use it now
            %---------------------------------------------------------------------------
            for k=1:num_runs
                load(fullfile(EXPERIMENT_ROOT_DIR,study,'behavioural',parafiles{k}),'con_info')
                if exist('con_info')
                    for contrast=1:length(con_info)
                        if k==1, con_vals{contrast} = []; end
                        if exist('RT') && RT_flag==1
                            con_vals{contrast} = [con_vals{contrast} con_info(contrast).vals 0];
                        else
                            con_vals{contrast} = [con_vals{contrast} con_info(contrast).vals];
                        end
                        con_name{contrast} = con_info(contrast).name;
                        n=numel(SPM.Sess(k).col)-(numel(con_info(contrast).vals)+(exist('RT') & RT_flag==1));
                        if n>0,
                            disp(['warning: incorrect number of contrast values for contrast #',num2str(contrast),' in run # ',num2str(k),' (',num2str(n),' values missing)']);
                            con_vals{contrast}=[con_vals{contrast},zeros(1,n)];
                        end
                    end
                end
            end
            for contrast=1:length(con_info)
                % if task is only 1 run, uncomment the following line
                % for regressors
                % con_vals{contrast}=[con_vals{contrast}, zeros(1,num_runs + num_regressors)]; %zero pad for effects of interest

                % if task is more than one run, use the following line for regressors
                con_vals{contrast}=[con_vals{contrast}, zeros(1,num_runs)];

                if isempty(SPM.xCon)
                    SPM.xCon = spm_FcUtil('Set', con_name{contrast}, 'T', 'c', con_vals{contrast}',SPM.xX.xKXs);
                else
                    SPM.xCon(end+1) = spm_FcUtil('Set', con_name{contrast}, 'T', 'c', con_vals{contrast}',SPM.xX.xKXs);
                end

            end %con_info loop
            % ---------------------------------------------------------------------------
            spm_contrasts_pleiades(SPM);
    end % task loop
end % subject loop
end %function model

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function skullStripMaker(study, subj, maskthresh)

    set(0,'DefaultFigureVisible','on');
    global mask_over;
    global inStruct;
    directory = ['/data/younglw/lab/' study '/derivatives/fmriprep/' subj '/anat/'];
    img = dir([directory 'sub-*MNI*preproc*.nii']);
    if isempty(img)
      try
        zipped = alek_get(directory, '*MNI*preproc*.nii.gz');
        fprintf('Gzip structural found!\n');
        fprintf('Unzipping...\n');
        gunzip(zipped);
        img = dir([directory 'sub-*MNI*preproc*.nii']);
        fprintf('Removing gzip anatomical...\n');
        eval(sprintf('!rm -rf %s',[directory '*MNI*preproc*.nii.gz']));
      catch
        pwd1 = pwd;
        cd(directory);
        img = spm_select(1,'*','Could not find proper anatomical file. Please select the anatomical file.');
        cd(pwd1);
      end
    else
      img = dir([directory 'sub-*MNI*preproc*.nii']);
      %fprintf('Removing gzip anatomical...\n');
      %eval(sprintf('!rm -rf %s',[directory '*MNI*preproc*.nii.gz']));
    end
    if strcmp(inStruct.src_data_flag,'unnormed')|isempty(img)
        img = dir([directory 'sub-*T1w_preproc.nii']);
        if isempty(img)
          try
            zipped = alek_get(directory, '*T1w_preproc.nii.gz');
            fprintf('Gzip structural found!\n');
            fprintf('Unzipping...\n');
            gunzip(zipped);
            img = dir([directory 'sub-*T1w_preproc.nii']);
            fprintf('Removing gzip anatomical...\n');
            eval(sprintf('!rm -rf %s',[directory '*T1w_preproc.nii.gz']));
          catch
            pwd1 = pwd;
            cd(directory);
            img = spm_select(1,'*','Could not find proper anatomical file. Please select the anatomical file.');
            cd(pwd1);
          end
        else
          img = dir([directory 'sub-*T1w_preproc.nii']);
          %fprintf('Removing gzip anatomical...\n');
          %eval(sprintf('!rm -rf %s',[directory '*T1w_preproc.nii.gz']));
        end
    elseif length(img) > 1
        pwd1 = pwd;
        cd(directory);
        img = spm_select(1,'*','There are too many anatomical files present. Please select the anatomical file.');
        cd(pwd1);
    else
        img = [directory img.name];
    end
    fprintf('Structural image file: \n');
    fprintf('%s\n',img);

    fprintf('Making mask image...\n');
    if ~exist([directory 'skull_strip_mask.img'],'file') | mask_over
        if exist([directory 'skull_strip_mask.img'],'file')
            fprintf('Old mask found!\n');
            fprintf('Attempting to remove old mask...\n');
            eval(sprintf('!rm -rf %s',[directory 'skull_strip_mask.nii.gz']));
            eval(sprintf('!rm -rf %s',[directory 'skull_strip_mask.nii']));
            eval(sprintf('!rm -rf %s',[directory 'skull_strip_mask.img']));

            fprintf('Old mask removed, making new mask...\n');
        end
        eval(sprintf('!bet %s %s -f %0.01f',img,[directory 'skull_strip_mask'],maskthresh));

        fprintf('Mask image made, unzipping...\n');
        eval(sprintf('!gunzip %s.nii.gz -f',[directory 'skull_strip_mask']));
        fprintf('Constructing binary brain mask...\n');
        V = spm_vol([directory 'skull_strip_mask.nii']);
        Vo = struct('fname',[directory 'skull_strip_mask.img'],'dim',[V(1).dim(1:3)],'dt',[spm_type('float32'), 1],'mat',V(1).mat,'descrip','spm - algebra','mask',1);
        Vo = spm_imcalc(V,Vo,'i1>0');
    end
    fprintf('Binary brain mask has been constructed successfully!\n');
    set(0,'DefaultFigureVisible','off');
end
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function art_maker(inStruct, resDir, artsubj, arttask)
global_mean=        inStruct.global_mean;               % global mean type (1: Standard 2: User-defined Mask)
motion_file_type=	inStruct.motion_file_type;          % motion file type (0: fmriprep .tsv file 1: FSL .par file 2:Siemens .txt file)
global_threshold=	inStruct.global_threshold;          % threshold for outlier detection based on global signal
motion_threshold=   inStruct.motion_threshold;          % threshold for outlier detection based on motion estimates
use_diff_motion=	inStruct.use_diff_motion;           % 1: uses scan-to-scan motion to determine outliers; 0: uses absolute motion
use_diff_global=	inStruct.use_diff_global;           % 1: uses scan-to-scan global signal change to determine outliers; 0: uses absolute global signal values
use_norms=          1;                                  % 1: uses composite motion measure (largest voxel movement) to determine outliers; 0: uses raw motion measures (translation/rotation parameters)
mask_file=          [];                                 % set to user-defined mask file(s) for global signal estimation (if global_mean is set to 2)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
STEPS=[1,1];
pwd1 = resDir;

if STEPS(1),
    files = fullfile(pwd1,'SPM.mat');
    for n1 = 1:size(files,1)
        cfgfile=fullfile(pwd,['art_config',num2str(n1,'%03d'),'.cfg']);
        fid=fopen(cfgfile,'wt');
        [filepath,filename,fileext]=fileparts(deblank(files(n1,:)));
        load(deblank(files(n1,:)),'SPM');
        fprintf(fid,'# Automatic script generated by %s\n',mfilename);
        fprintf(fid,'# Users can edit this file and use\n');
        fprintf(fid,'#   art(''sess_file'',''%s'');\n',cfgfile);
        fprintf(fid,'# to launch art using this configuration\n');
        fprintf(fid,'sessions: %d\n',length(SPM.Sess));
        fprintf(fid,'global_mean: %d\n',global_mean);
        fprintf(fid,'global_threshold: %f\n',global_threshold);
        fprintf(fid,'motion_threshold: %f\n',motion_threshold);
        fprintf(fid,'motion_file_type: %d\n',0);
        fprintf(fid,'motion_fname_from_image_fname: 1\n');
        fprintf(fid,'use_diff_motion: %d\n',use_diff_motion);
        fprintf(fid,'use_diff_global: %d\n',use_diff_global);
        fprintf(fid,'use_norms: %d\n',use_norms);
        fprintf(fid,'spm_file: %s\n',deblank(files(n1,:)));
        fprintf(fid,'output_dir: %s\n',fileparts(files(n1,:)));

        if ~isempty(mask_file)
            fprintf(fid,'mask_file: %s\n',deblank(mask_file(n1,:)));
        end

        fprintf(fid,'end\n');

        for n2=1:length(SPM.Sess)
            temp=[SPM.xY.P(SPM.Sess(n2).row,:),repmat(' ',[length(SPM.Sess(n2).row),1])]';
            fprintf(fid,'session %d image %s\n',n2,temp(:)');
        end

        fprintf(fid,'end\n');
        fclose(fid);
    end
end

if STEPS(2)
    for n1=1:size(files,1)
        cfgfile=fullfile(pwd,['art_config',num2str(n1,'%03d'),'.cfg']);
        disp(['running subject ',num2str(n1),' using config file ',cfgfile]);
        art_fmriprep('sess_file',cfgfile);
        set(gcf,'name',['art_batch: art subject #',num2str(n1)]);
    end
end
if inStruct.saveim
    eval(['saveas(get(0,''children''),' sprintf('''artifact_analysis_%s_%s.png''',artsubj,arttask) ')']);
end
close(get(0,'children'));
end
